<!--
/* assyrian-bible-workbench (Assyrian Keyboard & PDF Workbench) */
 * Copyright (C) 2025 AI Assyria
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
    /* Canvas for saving text as image (can be hidden or styled minimally) */More actions
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 /* You should have received a copy of the GNU General Public License */
#/* along with this program. If not, see <https://www.gnu.org/licenses/>.
-->


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Assyrian Keyboard & PDF Workbench</title>
    <!-- Favicon link (replace your-favicon.png with your actual favicon path) -->
    <link rel="icon" type="image/png" href="assyrian-text.png">
    <!-- Tailwind CSS CDN for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts for Syriac Scripts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Syriac+Eastern&family=Noto+Sans+Syriac+Estrangela&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the Assyrian font and keyboard layout */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Deep dark background for the entire page */
            color: #e2e8f0; /* Light text for general content */
            transition: none; /* No color transition as dark mode is permanent */
        }

        /* Base styles for all Assyrian text elements */
        .assyrian-text, .assyrian-letter {
            font-family: 'Noto Sans Syriac Estrangela', 'Noto Sans Syriac Eastern', 'Estrangelo Edessa', 'Segoe UI Historic', sans-serif;
            color: #e2e8f0; /* Light text for Assyrian characters on dark backgrounds */
            transition: none;
        }

        /* Specific font for Estrangela script */
        .estrangela-font {
            font-family: 'Noto Sans Syriac Estrangela', 'Estrangelo Edessa', 'Segoe UI Historic', sans-serif;
        }

        /* Specific font for Madnhaya (Eastern) script */
        .madnhaya-font {
            font-family: 'Noto Sans Syriac Eastern', 'Segoe UI Historic', sans-serif;
        }

        /* Styling for the main content container */
        .main-container {
            background-color: #2d3748; /* Lighter dark background for the main content panel */
            color: #e2e8f0; /* Light text for general content */
            border-radius: 0.5rem;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.4), 0 10px 10px -5px rgba(0, 0, 0, 0.2);
            padding: 1.5rem 2rem; /* Adjusted padding */
        }

        /* Styling for the input and output areas (pure white background) */
        .input-area, .output-area, #pdf-render-canvas, #output-canvas {
            min-height: 120px;
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid #d1d5db; /* Light border for white boxes */
            background-color: #FFFFFF; /* Pure white for text boxes/canvases */
            font-size: 1.25rem; /* Larger text for readability */
            line-height: 1.75;
            overflow-y: auto; /* Enable scrolling for long text */
            transition: none;
        }
        /* Specific text colors for content within white boxes */
        .input-area, .output-area {
            color: #1f2937; /* Dark text for primary content in white boxes */
        }
        .output-area.text-gray-600 { /* For transliteration specifically in white boxes */
            color: #4a5568; /* Slightly lighter dark text for secondary info */
        }

        /* Section backgrounds (lighter dark, same as main-container interior sections) */
        .section-background {
            background-color: #2d3748; /* Same as main container background */
            border-radius: 0.5rem;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.3); /* Inner shadow for sections */
            padding: 1rem;
        }
        /* For the specific PDF info box, removing bg-content-box and letting it inherit */
        /* Explicitly define text colors for elements within this section-background */
        .section-background h3,
        .section-background p,
        .section-background span {
            color: #e2e8f0 !important; /* Light text for headings, paragraphs, and spans */
        }
        /* Override for italic note within dark background sections */
        .section-background p.text-sm.italic {
            color: #cbd5e0 !important; /* Slightly subdued light text for notes */
        }

        /* PDF Viewer Canvas (inherits from .input-area styles but can be overridden) */
        #pdf-render-canvas, #output-canvas {
            display: block; /* Remove extra space below canvas */
            margin: 0 auto; /* Center the canvas */
            max-width: 100%; /* Ensure responsiveness */
            height: auto; /* Maintain aspect ratio */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        /* Hidden canvas for OCR processing */
        #ocr-hidden-canvas {
            display: none;
        }

        /* Keyboard button styling */
        .keyboard-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0.3rem 0.5rem; /* Reduced padding to fit content better */
            margin: 0.2rem; /* Slightly reduced margin */
            background-color: #4a5568; /* Darker button base color */
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out, color 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            min-width: 60px; /* Ensure buttons are not too narrow */
            height: 65px; /* Fixed height for consistency to prevent overflow */
        }
        /* Hover states for keyboard buttons */
        .keyboard-btn:hover:not(:disabled) {
            background-color: #6a7c93; /* Lighter dark button on hover */
            transform: translateY(-1px);
        }
        .keyboard-btn:active:not(:disabled) {
            background-color: #5d6e82; /* Even darker dark button on active */
            transform: translateY(0);
            box-shadow: none;
        }

        .keyboard-btn:disabled {
            background-color: #3b4553; /* Darker disabled */
            color: #718096; /* Darker faded text */
            cursor: not-allowed;
            box-shadow: none;
            opacity: 0.5; /* Visual feedback for disabled state */
        }

        .assyrian-letter {
            font-size: 1.8rem; /* Larger Assyrian character */
            font-weight: bold;
            color: #e2e8f0; /* Light text */
            line-height: 1; /* Tighter line height to prevent overflow */
            transition: none;
        }

        /* General Latin letter styling for primary labels on keys */
        .latin-letter {
            font-size: 0.9rem;
            color: #e2e8f0; /* Light text */
            margin-top: 0.2rem;
            line-height: 1; /* Tighter line height */
            transition: none;
        }

        /* Specific adjustments for QWERTY diacritic buttons to prevent overflow */
        .keyboard-btn .latin-label-qwerty-diacritic {
            font-size: 0.65rem; /* Smaller font size for number/symbol label */
            color: #e2e8f0;
            margin-top: 0; /* Adjust vertical spacing */
            line-height: 1; /* Tighter line height */
            visibility: hidden; /* Hide the Latin label for QWERTY diacritics as per user request */
        }


        /* New style for transliterated text on QWERTY diacritic keys AND Assyrian Letters keys */
        .latin-translit-label {
            font-size: 0.55rem; /* Even smaller for clarity under diacritic/letter */
            color: #cbd5e0; /* Slightly faded light text */
            margin-top: 0.1rem;
            line-height: 1; /* Tighter line height */
        }

        /* Base layout for the keyboard sections */
        #keyboard {
            display: flex;
            flex-direction: column; /* Stack rows vertically */
            align-items: center; /* Center the rows */
            background-color: #3b4553; /* Lighter dark background for the keyboard panel */
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.3);
        }

        /* Styles for inner rows within the keyboard */
        #keyboard .keyboard-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%; /* Take full width of parent to ensure new line */
            margin-bottom: 0.5rem; /* Space between rows */
        }
        #keyboard .keyboard-row:last-child {
            margin-bottom: 0; /* No margin after the last row */
        }

        /* Specific styling for RTL rows (Assyrian letters layout) */
        #keyboard .keyboard-row.rtl-flow {
            flex-direction: row-reverse; /* For RTL and bottom-to-top visual stacking */
        }

        /* Remove all Tailwind's default transitions or light mode overrides, as everything is hardcoded for dark mode */
        .bg-white, .text-gray-800, .text-gray-700, .text-gray-600, .bg-gray-50, .bg-gray-100, .border-gray-300, .shadow-xl, .shadow-md, .shadow, .shadow-inner {
            transition: none !important;
            /* Override potential light mode defaults from Tailwind CDN */
        }
        /* Specific overrides for elements to ensure dark mode values are always applied */
        select {
            background-color: #3b4553 !important;
            color: #e2e8f0 !important;
            border-color: #4a5568 !important;
        }
        /* File input specific styling for dark mode */
        .file\:bg-blue-50 {
            background-color: #4c5568 !important; /* Darker blue background */
        }
        .file\:text-blue-700 {
            color: #9cb3f0 !important; /* Lighter blue text */
        }
        .hover\:file\:bg-blue-100:hover {
            background-color: #6a7c93 !important; /* Even lighter blue on hover */
        }
        /* Ensure consistent heading and label colors across all contexts */
        h1, h2, h3 {
            color: #e2e8f0 !important; /* Ensure all headings are light text */
            text-align: left !important; /* Default to left align for headings */
        }
        /* Override specific heading alignment for the main title if needed */
        h1.text-center {
            text-align: center !important;
        }
        label {
            color: #cbd5e0 !important; /* Ensure all labels are light text */
            text-align: left !important; /* Labels should be left-aligned */
        }
        p {
            text-align: left !important; /* Paragraphs should be left-aligned */
        }
        span {
            /* Default span color to light, if not overridden by specific classes like text-gray-600 */
            color: inherit; /* Inherit from parent, or allow specific classes to apply */
        }
        /* Specific span in PDF info that needs dark text */
        .section-background .text-gray-700 span.font-medium {
             color: #1f2937 !important; /* Dark color for bold text in white box */
        }

        /* Special case for output areas with dir="rtl" to keep right alignment */
        #assyrian-input, #output, #pdf-extracted-text {
            text-align: right !important;
        }
        /* Special case for transliteration areas with dir="ltr" to keep left alignment */
        #transliteration, #pdf-transliterated-text {
            text-align: left !important;
        }

    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-4xl mx-auto main-container">
        <h1 class="text-3xl font-bold text-center mb-6">Assyrian Keyboard & PDF Workbench</h1>

        <div class="flex justify-center mb-4">
             <h2 class="text-xl font-bold">Assyrian Bible Workbench</h2>
        </div>


        <div class="mb-8 p-4 section-background">
            <h2 class="text-2xl font-semibold mb-4">PDF Reader & OCR</h2>

            <!-- The PDF information box - now dark mode friendly -->
            <div class="mb-6 p-4"> <!-- Removed bg-content-box here, styles are handled by CSS rules above -->
                <h3 class="text-xl font-semibold mb-2">Currently Displaying: American Bible Society in Modern Assyrian (1886 Edition)</h3>
                <p class="mb-1">
                    <span class="font-medium">Script:</span> Maḏnḥāyā (Eastern Syriac)
                </p>
                <p class="mb-2">
                    <span class="font-medium">Significance:</span> This is an important early print of the Assyrian Bible in the Eastern dialect, made accessible by the American Bible Society. It is a valuable resource for studying the Maḏnḥāyā script and its historical usage in biblical texts.
                </p>
                <p class="text-sm italic">
                    Note: The current OCR functionality relies on a generic Syriac ('syr') Tesseract model, which is primarily trained on Estrangelā. While it provides a good starting point, OCR accuracy for this specific Madnhaya font may vary and could significantly benefit from a custom-trained model.
                </p>
            </div>

            <div class="mb-4">
                <label for="pdf-upload" class="block text-lg font-medium mb-2">Or, upload another Assyrian PDF (from your computer):</label>
                <input type="file" id="pdf-upload" accept="application/pdf" class="block w-full text-sm text-gray-500
                    file:mr-4 file:py-2 file:px-4
                    file:rounded-full file:border-0
                    file:text-sm file:font-semibold
                    file:bg-blue-50 file:text-blue-700
                    hover:file:bg-blue-100"/>
            </div>

            <div class="flex justify-center items-center gap-4 mb-4">
                <button id="prev-page-btn" class="px-6 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed">Previous Page</button>
                <span id="page-num-display" class="text-lg font-medium">Page: - / -</span>
                <button id="next-page-btn" class="px-6 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed">Next Page</button>
            </div>
            <div id="ocr-status-display" class="text-center text-sm font-medium text-blue-700 mb-4"></div>

            <canvas id="pdf-render-canvas" class="mb-6"></canvas>
            <canvas id="ocr-hidden-canvas"></canvas>

            <h3 class="text-xl font-semibold mb-3">Extracted Text (from PDF/OCR):</h3>
            <div id="pdf-extracted-text" class="output-area mb-4" dir="rtl">
                No PDF loaded or no text extracted for this page yet.
            </div>

            <h3 class="text-xl font-semibold mb-3">Transliteration (from PDF/OCR):</h3>
            <div id="pdf-transliterated-text" class="output-area text-gray-600" dir="ltr">
                No PDF loaded or no text extracted for this page yet.
            </div>
        </div>

        <div class="mb-4">
            <label for="script-select" class="block text-lg font-medium mb-2">Select Script:</label>
            <select id="script-select" class="block w-full p-3 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 sm:text-lg">
                <option value="estrangela">Estrangelā (Classical)</option>
                <option value="madnhaya">Maḏnḥāyā (Eastern)</option>
            </select>
        </div>

        <div class="mb-6">
            <label for="keyboard-layout-select" class="block text-lg font-medium mb-2">Keyboard Layout:</label>
            <select id="keyboard-layout-select" class="block w-full p-3 border border-gray-300 rounded-md shadow-sm focus:ring-blue-500 focus:border-blue-500 sm:text-lg">
                <option value="assyrian">Assyrian Letters</option>
                <option value="qwerty">QWERTY (Latin Mapped)</option>
            </select>
        </div>

        <div class="mb-6">
            <button id="save-image-btn" class="mt-4 px-6 py-2 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700">Save Text as Image</button>
            <canvas id="output-canvas" style="display: none;"></canvas> <!-- Hidden canvas for drawing text to image -->
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
            <div>
                <h2 class="text-xl font-semibold mb-3">Transliteration (Input above):</h2>
                <div id="transliteration" class="output-area text-gray-600"></div>
            </div>
            <div>
                <h2 class="text-xl font-semibold mb-3">Assyrian Output (Input above):</h2>
                <div id="output" class="output-area assyrian-text" dir="rtl"></div>
            </div>
        </div>

        <div class="mb-6">
                        <label for="assyrian-input" class="block text-lg font-medium mb-2">Type Assyrian Here:</label>
            <textarea id="assyrian-input" class="input-area w-full focus:ring-blue-500 focus:border-blue-500 resize-y" placeholder="Start typing..." dir="rtl"></textarea>

            <h2 class="text-xl font-semibold mb-3">Assyrian Keyboard:</h2>
            <div id="keyboard" class="section-background">
                <!-- Keyboard buttons will be rendered here by JavaScript -->
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
    <script>
        // Set the workerSrc for pdf.js to load its worker script
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

        // Get references to the DOM elements
        const input = document.getElementById('assyrian-input');
        const output = document.getElementById('output');
        const scriptSelect = document.getElementById('script-select');
        const keyboardLayoutSelect = document.getElementById('keyboard-layout-select');
        const keyboardDiv = document.getElementById('keyboard');
        const transliterationDiv = document.getElementById('transliteration');

        // PDF elements
        const pdfUploadInput = document.getElementById('pdf-upload');
        const prevPageBtn = document.getElementById('prev-page-btn');
        const nextPageBtn = document.getElementById('next-page-btn');
        const pageNumDisplay = document.getElementById('page-num-display');
        const pdfRenderCanvas = document.getElementById('pdf-render-canvas');
        const ocrHiddenCanvas = document.getElementById('ocr-hidden-canvas'); // Hidden canvas for OCR
        const pdfExtractedTextDiv = document.getElementById('pdf-extracted-text');
        const pdfTransliteratedTextDiv = document.getElementById('pdf-transliterated-text');
        const ocrStatusDisplay = document.getElementById('ocr-status-display');
        const canvasContext = pdfRenderCanvas.getContext('2d');
        const ocrCanvasContext = ocrHiddenCanvas.getContext('2d'); // Context for hidden OCR canvas

        // Image Saving elements
        const saveImageBtn = document.getElementById('save-image-btn');
        const outputCanvas = document.getElementById('output-canvas');
        const outputCanvasCtx = outputCanvas.getContext('2d');

        // PDF variables
        let pdfDoc = null; // Stores the loaded PDF document
        let currentPageNum = 1; // Current page number being displayed

        // Tesseract.js Worker
        let ocrWorker = null; // Declare a variable to hold the Tesseract.js worker instance

        // Core Assyrian letters - kept in logical (A-Z equivalent) order for programmatic use
        const AshurayaLetters = [
            'ܐ', 'ܒ', 'ܓ', 'ܕ', 'ܗ', 'ܘ', 'ܙ', 'ܚ', 'ܛ', 'ܝ', 'ܟ',
            'ܠ', 'ܡ', 'ܢ', 'ܣ', 'ܥ', 'ܦ', 'ܨ', 'ܩ', 'ܪ', 'ܫ', 'ܬ'
        ];

        // --- Vowel and Diacritic Definitions per Script ---

        // Classical (Estrangelā) Vowels and Diacritics
        const estrangelaVowelsAndDiacritics = [
            'ܰ', // Pthaha (U+0730) - classical 'a'
            'ܳ', // Zqafa (U+0733) - classical 'o' (often 'a' in Eastern)
            'ܶ', // Rbasa (U+0736) - classical 'e'
            'ܺ', // Hbasa (U+073A) - classical 'i'
            'ܽ', // Esasa (U+0738) - classical 'u' (used with Waw)
            '݂', // quššāyā (hard mark)
            '݄'  // rukkākhā (soft mark)
        ];

        // Eastern (Maḏnḥāyā) Vowels and Diacritics
        const madnhayaVowelsAndDiacritics = [
            'ܲ', // pṯāḥā (U+0732)
            'ܵ', // zqāp̄ā (U+0735)
            'ܶ', // rḇāṣā ʾărīḵā (U+0736) - short e/i
            'ܹ', // rḇāṣā karyā (U+0739) - long e
            'ܼ', // ḥḇāṣā (U+073C, dot below for i/u)
            'ܿ', // ʿṣāṣā rwīḥā (U+073F, dot above for o)
            '݂', // quššāyā (hard mark)
            '݄'  // rukkākhā (soft mark)
        ];

        // Tooltips for diacritics - Conditional based on script
        const estrangelaDiacriticTooltips = {
            'ܰ': 'a – Pthaha (dot above, short a)',
            'ܳ': 'o / å – Zqafa (dot above, long o/a)',
            'ܶ': 'e – Rbasa (two horizontal dots below, short e)',
            'ܺ': 'i – Hbasa (dot below, short i)',
            'ܽ': 'u – Esasa (dot below, short u with waw)',
            '݂': "' – quššāyā (hard)",
            '݄': '· – rukkākhā (soft)'
        };

        const madnhayaDiacriticTooltips = {
            'ܲ': 'ă – pṯāḥā (dot above & below, short a)',
            'ܵ': 'ā – zqāp̄ā (two diagonal dots above, long a)',
            'ܶ': 'e / ĕ / i – rḇāṣā ʾărīḵā (two horizontal dots below, short e/i)',
            'ܹ': 'ē – rḇāṣā karyā (two diagonal dots below, long e)',
            'ܼ': 'ī / ū – ḥḇāṣā / ʿṣāṣā ʾălīṣā (dot below, for i or u with waw/yod)',
            'ܿ': 'ō – ʿṣāṣā rwīḥā (dot above, for o with waw)',
            '݂': "' – quššāyā (hard)",
            '݄': '· – rukkākhā (soft)'
        };

        // All vowels and diacritics combined, for QWERTY display (no filtering) and general validation
        const allVowelsAndDiacritics = [
            'ܲ', 'ܵ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', // Madnhaya
            'ܰ', 'ܳ', 'ܺ', 'ܽ', // Estrangela
            '݂', '݄' // Common hard/soft marks
        ];


        // General transliteration map (can be further refined for strict Estrangela vs Madnhaya transliteration)
        const transliterationMap = {
            'ܐ': 'ʾ', 'ܒ': 'b', 'ܓ': 'g', 'ܕ': 'd', 'ܗ': 'h', 'ܘ': 'w',
            'ܙ': 'z', 'ܚ': 'ḥ', 'ܛ': 'ṭ', 'ܝ': 'y', 'ܟ': 'k', 'ܠ': 'l',
            'ܡ': 'm', 'ܢ': 'n', 'ܣ': 's', 'ܥ': 'ʿ', 'ܦ': 'p', 'ܨ': 'ṣ',
            'ܩ': 'q', 'ܪ': 'r', 'ܫ': 'š', 'ܬ': 't',
            'ܰ': 'a', // Estrangela Pthaha
            'ܳ': 'o', // Estrangela Zqafa (Western pronunciation)
            'ܶ': 'e', // Common Rbasa (Estrangela) / Rbasa Aricaha (Madnhaya)
            'ܺ': 'i', // Estrangela Hbasa
            'ܽ': 'u', // Estrangela Esasa
            'ܲ': 'ă', // Madnhaya Pthaha
            'ܵ': 'ā', // Madnhaya Zqafa
            'ܹ': 'ē', // Madnhaya Rbasa Karyaha
            'ܼ': 'ī', // Madnhaya Hbasa/Asasa dot below
            'ܿ': 'ō', // Madnhaya Esasa dot above
            '݂': "'",
            '݄': ''
        };

        // Map letters to allowed diacritics. This is crucial for correct input.
        // This map remains broad to allow all possible attachments, filtering for display happens at button rendering.
        const validDiacriticsMap = {
            'ܐ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܿ', 'ܽ', 'ܰ', 'ܳ', 'ܺ'], // Added Estrangela vowels to possible attachments
            'ܒ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', 'ܽ', '݂', '݄', 'ܰ', 'ܳ', 'ܺ'],
            'ܓ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', 'ܽ', '݂', '݄', 'ܰ', 'ܳ', 'ܺ'],
            'ܕ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', 'ܽ', '݂', '݄', 'ܰ', 'ܳ', 'ܺ'],
            'ܗ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', 'ܽ', 'ܰ', 'ܳ', 'ܺ'],
            'ܘ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', 'ܽ', 'ܰ', 'ܳ', 'ܺ'],
            'ܙ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', 'ܽ', 'ܰ', 'ܳ', 'ܺ'],
            'ܚ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', 'ܽ', 'ܰ', 'ܳ', 'ܺ'],
            'ܛ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', 'ܽ', 'ܰ', 'ܳ', 'ܺ'],
            'ܝ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', 'ܽ', 'ܰ', 'ܳ', 'ܺ'],
            'ܟ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', 'ܽ', '݂', '݄', 'ܰ', 'ܳ', 'ܺ'],
            'ܠ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', 'ܽ', 'ܰ', 'ܳ', 'ܺ'],
            'ܡ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', 'ܽ', 'ܰ', 'ܳ', 'ܺ'],
            'ܢ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', 'ܽ', 'ܰ', 'ܳ', 'ܺ'],
            'ܣ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', 'ܽ', 'ܰ', 'ܳ', 'ܺ'],
            'ܥ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', 'ܽ', 'ܰ', 'ܳ', 'ܺ'],
            'ܦ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', 'ܽ', '݂', '݄', 'ܰ', 'ܳ', 'ܺ'],
            'ܨ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', 'ܽ', 'ܰ', 'ܳ', 'ܺ'],
            'ܩ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', 'ܽ', 'ܰ', 'ܳ', 'ܺ'],
            'ܪ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', 'ܽ', 'ܰ', 'ܳ', 'ܺ'],
            'ܫ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', 'ܽ', 'ܰ', 'ܳ', 'ܺ'],
            'ܬ': ['ܵ', 'ܲ', 'ܸ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', 'ܽ', '݂', '݄', 'ܰ', 'ܳ', 'ܺ']
        };

        // Mapping of physical keyboard keys to Assyrian characters and diacritics
        const physicalKeyToAssyrianMap = {
            // Base Letters (approximate phonetic or common layouts)
            'q': 'ܩ', 'w': 'ܘ', 'e': 'ܐ', 'r': 'ܪ', 't': 'ܬ', 'y': 'ܝ', 'u': 'ܘ', 'i': 'ܝ', 'o': 'ܘ', 'p': 'ܦ',
            'a': 'ܐ', 's': 'ܣ', 'd': 'ܕ', 'f': 'ܫ', 'g': 'ܓ', 'h': 'ܗ', 'j': 'ܚ', 'k': 'ܟ', 'l': 'ܠ',
            'z': 'ܙ', 'x': 'ܨ', 'c': 'ܥ', 'v': 'ܒ', 'b': 'ܒ', 'n': 'ܢ', 'm': 'ܡ',

            // Diacritics (using Shift + a key, or specific symbols/numbers)
            // Note: These mappings apply generally, and the virtual keyboard display filters.
            'A': 'ܵ', // Shift+A for Zqapa (Madnhaya ā)
            'S': 'ܲ', // Shift+S for Ptaha (Madnhaya ă)
            'D': 'ܶ', // Shift+D for Rbasa (Common e/i)
            'F': 'ܹ', // Shift+F for Rbasa Karyaha (Madnhaya ē)
            'G': 'ܼ', // Shift+G for Hbasa/Hruca (Madnhaya i/u dot below)
            'H': 'ܿ', // Shift+H for Esasa (Madnhaya o dot above)
            'J': 'ܳ', // Shift+J for Estrangela Zqafa (classical o)
            'X': 'ܰ', // Shift+X for Estrangela Pthaha (classical a)
            'C': 'ܺ', // Shift+C for Estrangela Hbasa (classical i)
            'V': 'ܽ', // Shift+V for Estrangela Esasa (classical u)
            'K': '݂', // Shift+K for Qushaya (hard)
            'L': '݄', // Shift+L for Rukkakha (soft)

            // Shift + Number mappings for diacritics/vowels (preferred for clarity)
            '1': 'ܵ', // Shift+1 for Zqapa (Madnhaya ā)
            '2': 'ܲ', '3': 'ܶ', '4': 'ܹ', '5': 'ܼ', '6': 'ܿ', '7': 'ܰ', '8': 'ܳ', '9': 'ܺ', '0': 'ܽ', // Shifted numbers to diacritics
            '-': '݂', // Hyphen for Qushaya
            '=': '݄' // Equals for Rukkakha
        };

        // QWERTY keyboard rows for display on the virtual keyboard
        const qwertyDisplayRows = [
            ['q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p'],
            ['a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l'],
            ['z', 'x', 'c', 'v', 'b', 'n', 'm'],
        ];


        /**
         * Helper function to determine if a diacritic can be inserted at the current cursor position.
         * This function mimics the validation logic in insertAtCursor without actually modifying the input.
         * @param {string} char - The diacritic character to check.
         * @param {string} value - The current value of the input textarea.
         * @param {number} cursorPos - The current cursor position in the textarea.
         * @returns {boolean} True if the diacritic can be inserted, false otherwise.
         */
        function canInsertDiacritic(char, value, cursorPos) {
            // A diacritic must follow a base letter. Find the character immediately preceding the cursor.
            let baseCharIndex = cursorPos - 1;
            // Move backwards to find the actual base letter, skipping any diacritics already present
            while (baseCharIndex >= 0 && allVowelsAndDiacritics.includes(value[baseCharIndex])) {
                baseCharIndex--;
            }
            const baseChar = baseCharIndex >= 0 ? value[baseCharIndex] : '';

            // If no base character found at all, then no diacritic can be inserted.
            if (!baseChar) {
                return false;
            }

            // Check if the diacritic is allowed on this specific base letter based on the current script.
            const currentScript = scriptSelect.value;
            const allowedDiacriticsForBase = validDiacriticsMap[baseChar] || [];
            const relevantAllowedDiacritics = allowedDiacriticsForBase.filter(d =>
                (currentScript === 'madnhaya' && madnhayaVowelsAndDiacritics.includes(d)) ||
                (currentScript === 'estrangela' && estrangelaVowelsAndDiacritics.includes(d)) ||
                (['݂', '݄'].includes(d)) // Always allow hard/soft marks regardless of script type in validDiacriticsMap
            );

            if (!relevantAllowedDiacritics.includes(char)) {
                return false; // Diacritic not allowed on this base letter for the current script
            }

            const primaryVowels = [
                ...estrangelaVowelsAndDiacritics.filter(v => !['݂', '݄'].includes(v)),
                ...madnhayaVowelsAndDiacritics.filter(v => !['݂', '݄'].includes(v))
            ];
            
            // Analyze existing diacritics attached to the base character, up to the cursor position.
            // This loop identifies what diacritics are *already* present on the last typed base letter.
            let hasExistingPrimaryVowel = false;
            let hasExistingHardMark = false;
            let hasExistingSoftMark = false;

            for (let i = baseCharIndex + 1; i < cursorPos; i++) {
                const existingChar = value[i];
                if (primaryVowels.includes(existingChar)) {
                    hasExistingPrimaryVowel = true;
                } else if (existingChar === '݂') {
                    hasExistingHardMark = true;
                } else if (existingChar === '݄') {
                    hasExistingSoftMark = true;
                }
            }


            // Rule 1: Prevent inserting a primary vowel if one is already attached to the same base letter.
            // Orthographically, a single base letter typically takes one primary vowel.
            if (primaryVowels.includes(char) && hasExistingPrimaryVowel) {
                return false;
            }

            // Rule 2: Prevent inserting a hard mark if a soft mark already exists (and vice-versa) on the same base letter.
            // Hard and soft marks denote mutually exclusive pronunciations.
            if (char === '݂' && hasExistingSoftMark) {
                return false;
            }
            if (char === '݄' && hasExistingHardMark) {
                return false;
            }

            // Rule 3: Prevent "stacking" in transliteration by being more restrictive.
            // If a primary vowel is already present, prevent adding hard/soft marks (and vice-versa).
            // This is to avoid transliteration output like "bă`" if the user perceives this as "stacking".
            if (['݂', '݄'].includes(char) && hasExistingPrimaryVowel) {
                return false; // Disables hard/soft mark if primary vowel exists
            }
            if (primaryVowels.includes(char) && (hasExistingHardMark || hasExistingSoftMark)) {
                return false; // Disables primary vowel if hard/soft mark exists
            }


            return true; // All checks passed, diacritic can be inserted.
        }


        /**
         * Renders the virtual keyboard based on the selected script and layout.
         * @param {string} script - The selected script ('madnhaya' or 'estrangela') for font.
         * @param {string} layout - The selected keyboard layout ('assyrian' or 'qwerty').
         */
        function renderKeyboard(script, layout) {
            keyboardDiv.innerHTML = ''; // Clear existing keyboard buttons

            const currentInputValue = input.value;
            const currentCursorPos = input.selectionStart;


            if (layout === 'qwerty') {
                // QWERTY Layout: Main Letters Row
                qwertyDisplayRows.forEach(row => {
                    const rowDiv = document.createElement('div');
                    rowDiv.classList.add('keyboard-row', 'flex-row'); // Explicitly LTR
                    row.forEach(key => {
                        const btn = document.createElement('button');
                        btn.classList.add('keyboard-btn');

                        const topSpan = document.createElement('div');
                        topSpan.textContent = key.toUpperCase(); // Display the Latin key
                        topSpan.className = 'latin-letter';

                        const bottomSpan = document.createElement('div');
                        bottomSpan.textContent = physicalKeyToAssyrianMap[key.toLowerCase()] || '';
                        bottomSpan.className = 'assyrian-letter ' + script + '-font';

                        btn.appendChild(topSpan);
                        btn.appendChild(bottomSpan);
                        btn.onclick = () => insertAtCursor(physicalKeyToAssyrianMap[key.toLowerCase()] || key, true);
                        rowDiv.appendChild(btn);
                    });
                    keyboardDiv.appendChild(rowDiv);
                });

                // QWERTY Layout: Diacritics Row (without number assignments, only transliterations)
                const diacriticQwertyRowDiv = document.createElement('div');
                diacriticQwertyRowDiv.classList.add('keyboard-row', 'flex-row', 'mt-2'); // Explicitly LTR, add some margin-top

                // Define explicit mapping for diacritics to be displayed in the QWERTY layout's diacritic row
                const qwertyDiacriticCharacters = [
                    'ܵ', 'ܲ', 'ܶ', 'ܹ', 'ܼ', 'ܿ', // Madnhaya
                    'ܰ', 'ܳ', 'ܺ', 'ܽ', // Estrangela
                    '݂', '݄' // Common hard/soft marks
                ];
                
                // Sort for consistent display order (can be alphabetical or manual)
                // For now, retaining the order as defined in qwertyDiacriticCharacters
                
                qwertyDiacriticCharacters.forEach(char => {
                    const btn = document.createElement('button');
                    btn.classList.add('keyboard-btn');

                    const charSpan = document.createElement('div');
                    charSpan.textContent = char; // Display the diacritic
                    charSpan.className = 'assyrian-letter ' + script + '-font';

                    const translitSpan = document.createElement('div');
                    translitSpan.textContent = transliterationMap[char] || ''; // Display transliteration
                    translitSpan.className = 'latin-translit-label'; // Specific class for smaller translit

                    btn.appendChild(charSpan);
                    btn.appendChild(translitSpan);
                    btn.onclick = () => insertAtCursor(char, false);

                    // Apply disability conditionality
                    const shouldEnable = canInsertDiacritic(char, currentInputValue, currentCursorPos);
                    if (!shouldEnable) {
                        btn.disabled = true;
                        btn.classList.add('opacity-50', 'cursor-not-allowed');
                    } else {
                        btn.disabled = false;
                        btn.classList.remove('opacity-50', 'cursor-not-allowed');
                    }

                    diacriticQwertyRowDiv.appendChild(btn);
                });
                keyboardDiv.appendChild(diacriticQwertyRowDiv);

            } else { // Assyrian Letters layout
                // Main Letters Row (RTL and bottom-to-top stacking)
                const lettersRowDiv = document.createElement('div');
                lettersRowDiv.classList.add('keyboard-row', 'rtl-flow');
                AshurayaLetters.forEach(letter => {
                    const btn = document.createElement('button');
                    btn.classList.add('keyboard-btn');
                    btn.classList.add(script + '-font');

                    const topSpan = document.createElement('div');
                    topSpan.textContent = letter;
                    topSpan.className = 'assyrian-letter';

                    const bottomSpan = document.createElement('div');
                    bottomSpan.textContent = transliterationMap[letter] || '';
                    bottomSpan.className = 'latin-translit-label'; // Use latin-translit-label for consistency

                    btn.appendChild(topSpan);
                    btn.appendChild(bottomSpan);
                    btn.onclick = () => insertAtCursor(letter, true);
                    lettersRowDiv.appendChild(btn);
                });
                keyboardDiv.appendChild(lettersRowDiv);

                // Diacritics Row (RTL and bottom-to-top stacking, on a new line)
                const diacriticsRowDiv = document.createElement('div');
                diacriticsRowDiv.classList.add('keyboard-row', 'rtl-flow', 'mt-2');
                const currentScriptVowelsAndDiacritics = script === 'madnhaya' ? madnhayaVowelsAndDiacritics : estrangelaVowelsAndDiacritics;

                currentScriptVowelsAndDiacritics.forEach(char => {
                    const btn = document.createElement('button');
                    btn.classList.add('keyboard-btn');
                    btn.classList.add(script + '-font');

                    const topSpan = document.createElement('div');
                    topSpan.textContent = char;
                    topSpan.className = 'assyrian-letter';

                    const bottomSpan = document.createElement('div');
                    bottomSpan.textContent = transliterationMap[char] || '';
                    bottomSpan.className = 'latin-translit-label';

                    btn.appendChild(topSpan);
                    btn.appendChild(bottomSpan);

                    const isBase = false; // These are diacritics
                    btn.onclick = () => insertAtCursor(char, isBase);

                    // Apply disability conditionality
                    const shouldEnable = canInsertDiacritic(char, currentInputValue, currentCursorPos);
                    if (!shouldEnable) {
                        btn.disabled = true;
                        btn.classList.add('opacity-50', 'cursor-not-allowed');
                    } else {
                        btn.disabled = false;
                        btn.classList.remove('opacity-50', 'cursor-not-allowed');
                    }

                    diacriticsRowDiv.appendChild(btn);
                });
                keyboardDiv.appendChild(diacriticsRowDiv);
            }
        }

        /**
         * Inserts a character at the current cursor position in the input field.
         * Handles logic for preventing invalid diacritic combinations.
         * @param {string} char - The character to insert.
         * @param {boolean} isBase - True if the character is a base Assyrian letter, false for diacritics.
         */
        function insertAtCursor(char, isBase = false) {
            const cursorPos = input.selectionStart;
            const value = input.value;

            // Diacritic validation logic (more robust to prevent invalid stacking)
            if (!isBase && allVowelsAndDiacritics.includes(char)) { // Check against all possible diacritics
                // Use the canInsertDiacritic helper for consistency.
                if (!canInsertDiacritic(char, value, cursorPos)) {
                    return; // Do not insert if validation fails.
                }
            }


            const before = value.slice(0, cursorPos);
            const after = value.slice(cursorPos);
            input.value = before + char + after;

            input.focus();
            input.selectionStart = input.selectionEnd = cursorPos + char.length;

            updateOutput();
        }

        /**
         * Updates the output displays (Assyrian text and transliteration)
         * and re-renders keyboard and diacritic buttons based on the current input.
         */
        function updateOutput() {
            const script = scriptSelect.value;
            // Apply script-specific font class
            input.className = `input-area w-full focus:ring-blue-500 focus:border-blue-500 resize-y ${script}-font`;
            output.className = `output-area assyrian-text ${script}-font`;
            output.textContent = input.value;
            transliterationDiv.textContent = transliterate(input.value);

            // Re-render keyboard to update diacritic button states based on current cursor position
            renderKeyboard(scriptSelect.value, keyboardLayoutSelect.value);
        }

        /**
         * Transliterates the given Assyrian text into Latin characters.
         * @param {string} text - The Assyrian text to transliterate.
         * @returns {string} The transliterated text.
         */
        function transliterate(text) {
            let result = '';
            for (const char of text) {
                result += transliterationMap[char] || char;
            }
            return result;
        }

        // --- PDF.js Functions ---

        /**
         * Loads a PDF document from a File object or a URL.
         * @param {File | string} source - The PDF File object or a URL string.
         */
        async function loadPdf(source) {
            try {
                let pdfData;
                if (source instanceof File) {
                    // Handle File object from input type="file"
                    const fileReader = new FileReader();
                    pdfData = await new Promise((resolve, reject) => {
                        fileReader.onload = () => resolve(new Uint8Array(fileReader.result));
                        fileReader.onerror = reject;
                        fileReader.readAsArrayBuffer(source);
                    });
                } else if (typeof source === 'string') {
                    // Handle URL string
                    if (!source.startsWith('http://') && !source.startsWith('https://')) {
                         throw new Error('Invalid URL format. Must start with http:// or https://');
                    }
                    const response = await fetch(source);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status} - ${response.statusText}`);
                    }
                    pdfData = new Uint8Array(await response.arrayBuffer());
                } else {
                    throw new Error('Invalid PDF source provided. Must be a File or a URL string.');
                }

                pdfDoc = await pdfjsLib.getDocument({ data: pdfData }).promise;
                currentPageNum = 1;
                renderPage(currentPageNum);
                // Enable navigation buttons
                prevPageBtn.disabled = true; // First page, so previous is disabled
                nextPageBtn.disabled = pdfDoc.numPages <= 1; // Disable next if only one page
            } catch (error) {
                console.error('Error loading PDF:', error);
                // Using a custom message box instead of alert()
                const errorMessage = document.createElement('div');
                errorMessage.textContent = `Failed to load PDF: ${error && error.message ? error.message : 'Unknown error'}. Please ensure it is a valid PDF and, if using a URL, that it is accessible.`;
                errorMessage.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background-color: #f8d7da; color: #721c24; padding: 10px 20px; border-radius: 5px; border: 1px solid #f5c6cb; z-index: 1000;';
                document.body.appendChild(errorMessage);
                setTimeout(() => errorMessage.remove(), 7000); // Remove after 7 seconds

                pdfDoc = null;
                currentPageNum = 1;
                pageNumDisplay.textContent = 'Page: - / -';
                pdfRenderCanvas.width = 0;
                pdfRenderCanvas.height = 0;
                pdfExtractedTextDiv.textContent = 'Failed to load PDF.';
                pdfTransliteratedTextDiv.textContent = 'Failed to load PDF.';
                prevPageBtn.disabled = true;
                nextPageBtn.disabled = true;
            }
        }

        /**
         * Renders a specific page of the loaded PDF.
         * Attempts to extract text first, then falls back to OCR if no text is found.
         * @param {number} pageNumber - The page number to render.
         */
        async function renderPage(pageNumber) {
            if (!pdfDoc) return;

            currentPageNum = pageNumber;
            pageNumDisplay.textContent = `Page: ${currentPageNum} / ${pdfDoc.numPages}`;

            // Update button states
            prevPageBtn.disabled = currentPageNum <= 1;
            nextPageBtn.disabled = currentPageNum >= pdfDoc.numPages;

            pdfExtractedTextDiv.textContent = 'Extracting text...';
            pdfTransliteratedTextDiv.textContent = 'Transliterating...';
            ocrStatusDisplay.textContent = ''; // Clear previous OCR status

            try {
                const page = await pdfDoc.getPage(pageNumber);
                const viewport = page.getViewport({ scale: 2.0 }); // Increased scale for better OCR quality

                // --- Render PDF to main canvas (for display) ---
                pdfRenderCanvas.height = viewport.height;
                pdfRenderCanvas.width = viewport.width;
                const renderContext = {
                    canvasContext: canvasContext,
                    viewport: viewport
                };
                await page.render(renderContext).promise;

                // --- Attempt to extract text layer ---
                const textContent = await page.getTextContent();
                let pageText = '';

                if (textContent.items.length > 0) {
                    // Filter out empty strings and join
                    pageText = textContent.items.map(item => item.str).filter(str => str.trim() !== '').join(' ');
                }

                // Heuristic check: if the extracted text is empty or predominantly Latin characters, proceed with OCR.
                const containsSyriacCharacters = /[ܐ-ܬ݀-ݎ]/g.test(pageText); // Basic check for Syriac Unicode range
                const isMostlyLatin = /[a-zA-Z0-9]/.test(pageText.trim()) && !containsSyriacCharacters;


                if (pageText.trim() !== '' && containsSyriacCharacters && !isMostlyLatin) {
                    // Found text, and it appears to be Syriac (not just Latin characters)
                    pdfExtractedTextDiv.textContent = pageText;
                    pdfTransliteratedTextDiv.textContent = transliterate(pageText);
                    ocrStatusDisplay.textContent = 'Text extracted from PDF layer.';
                } else {
                    // No selectable text, or extracted text seems to be Latin/garbage. Attempt OCR.
                    ocrStatusDisplay.textContent = 'No digital text layer or non-Latin text found. Running OCR...';
                    pdfExtractedTextDiv.textContent = 'Running OCR... (this may take a moment)';
                    pdfTransliteratedTextDiv.textContent = 'Running OCR...';

                    // --- Render PDF to hidden canvas (for OCR) ---
                    ocrHiddenCanvas.height = viewport.height;
                    ocrHiddenCanvas.width = viewport.width;
                    const ocrRenderContext = {
                        canvasContext: ocrCanvasContext,
                        viewport: viewport
                    };
                    await page.render(ocrRenderContext).promise;

                    // Ensure OCR worker is ready
                    if (!ocrWorker) {
                        ocrStatusDisplay.textContent = 'Loading OCR engine (core files)...';
                        ocrWorker = await Tesseract.createWorker({
                            // Explicitly set workerPath for consistency.
                            workerPath: 'https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/worker.min.js',
                            // Updated langPath to JSDelivr path for syr (Syriac)
                            langPath: 'https://cdn.jsdelivr.net/npm/@tesseract.js-data/syr@1.0.0/4.0.0_best_int/', // Corrected to 'syr'
                            logger: m => {
                                if (m.status && m.progress !== undefined) {
                                    if (m.status === 'loading tesseract core') {
                                        ocrStatusDisplay.textContent = `OCR Core: ${Math.round(m.progress * 100)}% loaded`;
                                    } else if (m.status === 'initializing tesseract') {
                                        ocrStatusDisplay.textContent = `OCR Initializing: ${Math.round(m.progress * 100)}%`;
                                    } else {
                                        ocrStatusDisplay.textContent = `OCR: ${m.status} (${Math.round(m.progress * 100)}%)`;
                                    }
                                }
                            }
                        });
                        ocrStatusDisplay.textContent = 'OCR Engine: Loading language data...';
                        await ocrWorker.loadLanguage('syr'); // Corrected to 'syr'
                        ocrStatusDisplay.textContent = 'OCR Engine: Initializing language...';
                        await ocrWorker.initialize('syr'); // Corrected to 'syr'
                        ocrStatusDisplay.textContent = 'OCR Engine ready.';
                    }

                    console.log('Attempting OCR with canvas:', ocrHiddenCanvas); // Added for debugging
                    // --- Perform OCR using Tesseract.js worker ---
                    const { data: { text } } = await ocrWorker.recognize(ocrHiddenCanvas);

                    pageText = text.trim();

                    pdfExtractedTextDiv.textContent = pageText || 'OCR found no text or failed to recognize.';
                    pdfTransliteratedTextDiv.textContent = transliterate(pageText);
                    ocrStatusDisplay.textContent = pageText ? 'OCR complete.' : 'OCR complete, no text found.';
                }

            } catch (error) {
                console.error('Error rendering page or extracting text/OCR:', error);
                pdfExtractedTextDiv.textContent = 'Error processing page.';
                pdfTransliteratedTextDiv.textContent = 'Error processing page.';
                // Enhanced error message for user with error.message check
                let userMessage = `Error during PDF processing or OCR: ${error && error.name ? error.name : 'Unknown Error'}: ${error && error.message ? error.message : 'No message available'}.`;
                if (error && error.message && (error.message.includes('Failed to fetch') || error.message.includes('Can not load'))) {
                    userMessage += ' This often happens if the page is not served by a local web server (e.g., you opened it directly from your file system). Please ensure you are using a local server (like Python\'s http.server) and try a hard refresh (Ctrl+Shift+R or Cmd+Shift+R) after clearing your browser\'s cache.';
                } else if (error && error.name === 'DataCloneError') {
                     userMessage += ' This suggests an issue with the Web Worker. Please try a hard refresh (Ctrl+Shift+R or Cmd+Shift+R) and clear your browser\'s cache to ensure consistent Tesseract.js component loading.';
                } else if (error && error.message.includes('Tesseract.js: Failed to load language data. You may need to provide a custom "langPath".')) {
                    userMessage += ` It appears the language data for 'syr' could not be loaded from the specified path. Double-check your internet connection and verify that 'https://cdn.jsdelivr.net/npm/@tesseract.js-data/syr@1.0.0/4.0.0_best_int/' is accessible.`;
                }
                ocrStatusDisplay.textContent = userMessage;
            }
        }

        // --- Image Saving Function ---
        /**
         * Saves the current text from the manual input area as a PNG image.
         */
        function saveInputTextAsImage() {
            const textToSave = input.value;
            if (!textToSave.trim()) {
                const infoMessage = document.createElement('div');
                infoMessage.textContent = 'Please type some Assyrian text to save as an image.';
                infoMessage.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background-color: #f8d7da; color: #721c24; padding: 10px 20px; border-radius: 5px; border: 1px solid #f5c6cb; z-index: 1000;'; // Changed to error style
                document.body.appendChild(infoMessage);
                setTimeout(() => infoMessage.remove(), 3000);
                return;
            }

            const currentScript = scriptSelect.value;
            // Use the correct font family names as defined in CSS
            const fontName = currentScript === 'madnhaya' ? 'Noto Sans Syriac Eastern' : 'Noto Sans Syriac Estrangela';
            const fontSize = 80; // Adjust as needed
            const padding = 20; // Padding around the text

            // Measure text to set canvas dimensions dynamically
            outputCanvasCtx.font = `${fontSize}px "${fontName}"`;
            const textMetrics = outputCanvasCtx.measureText(textToSave);
            const textWidth = textMetrics.width;
            const textHeight = fontSize; // Approximate height

            // Set canvas dimensions
            outputCanvas.width = textWidth + (padding * 2);
            outputCanvas.height = textHeight + (padding * 2);

            // Redraw content with new dimensions
            outputCanvasCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            outputCanvasCtx.font = `${fontSize}px "${fontName}"`;
            outputCanvasCtx.textAlign = 'center';
            outputCanvasCtx.textBaseline = 'middle';
            outputCanvasCtx.fillStyle = '#000'; // Black text
            // Draw text, adjusted for RTL and centering
            outputCanvasCtx.fillText(textToSave, outputCanvas.width / 2, outputCanvas.height / 2);

            // Create a download link
            const link = document.createElement('a');
            link.download = `assyrian-text-${encodeURIComponent(textToSave.substring(0, 10))}.png`; // Use first few chars for filename
            link.href = outputCanvas.toDataURL('image/png');
            link.click();

            // Optionally, briefly show the canvas or provide feedback
            // For now, it will just download.
        }

        // --- Event Listeners ---

        // Initial rendering based on current selections
        renderKeyboard(scriptSelect.value, keyboardLayoutSelect.value);
        updateOutput(); // Updates the manual input/output fields

        // Event listener for changes in the input field (manual typing or programmatic changes)
        input.addEventListener('input', updateOutput);
        // Event listener for changes in the script selection dropdown
        scriptSelect.addEventListener('change', () => {
            renderKeyboard(scriptSelect.value, keyboardLayoutSelect.value); // Pass both current values
            updateOutput();
            // Also update PDF transliteration if a PDF is loaded and text is extracted
            if (pdfDoc) {
                renderPage(currentPageNum); // Re-render page to apply new transliteration font
            }
        });
        // NEW: Event listener for changes in the keyboard layout selection dropdown
        keyboardLayoutSelect.addEventListener('change', () => {
            renderKeyboard(scriptSelect.value, keyboardLayoutSelect.value); // Pass both current values
            // No direct impact on text content, so no updateOutput() or PDF re-render needed.
        });

        // Add a click listener to the document to re-render keyboard (for diacritic enabling/disabling)
        document.addEventListener('click', (event) => {
            // Re-render keyboard on any click to ensure diacritic buttons are correctly enabled/disabled
            // based on cursor position or text content.
            // This is a broad listener but ensures reactivity without complex event delegation on individual keys.
            renderKeyboard(scriptSelect.value, keyboardLayoutSelect.value);
        });

        // Add a keyup listener to the input field to re-render keyboard (for diacritic enabling/disabling)
        input.addEventListener('keyup', (event) => {
            // Re-render keyboard on keyup for cursor movement or text changes
            renderKeyboard(scriptSelect.value, keyboardLayoutSelect.value);
        });


        // Add event listener for physical keyboard input
        input.addEventListener('keydown', (event) => {
            // Allow browser defaults for control keys and navigation
            if (event.ctrlKey || event.altKey || event.metaKey || event.key === 'Backspace' || event.key === 'Delete' ||
                event.key.startsWith('Arrow') || event.key === 'Tab' || event.key === 'Home' || event.key === 'End' ||
                event.key === 'Shift' || event.key === 'Control' || event.key === 'Alt' || event.key === 'Meta') {
                return;
            }

            let charToInsert = null;
            let isBaseCharacter = true;

            // Handle QWERTY layout specific physical key mappings
            const currentLayout = keyboardLayoutSelect.value;

            if (currentLayout === 'qwerty') {
                // Physical key map for QWERTY diacritics still uses numbers for physical input
                const qwertyPhysicalDiacriticMap = {
                    '1': 'ܵ', '2': 'ܲ', '3': 'ܶ', '4': 'ܹ', '5': 'ܼ',
                    '6': 'ܿ', '7': 'ܰ', '8': 'ܳ', '9': 'ܺ', '0': 'ܽ',
                    '-': '݂',
                    '=': '݄'
                };
                if (qwertyPhysicalDiacriticMap[event.key]) {
                    charToInsert = qwertyPhysicalDiacriticMap[event.key];
                    isBaseCharacter = false; // It's a diacritic
                    event.preventDefault(); // Prevent default number/symbol input
                }
                // If not a number/symbol, check for letter keys
                else if (physicalKeyToAssyrianMap[event.key.toLowerCase()]) {
                    charToInsert = physicalKeyToAssyrianMap[event.key.toLowerCase()];
                    isBaseCharacter = true; // These are base letters
                    event.preventDefault(); // Prevent default Latin letter input
                }
            }
            // For Assyrian Letters layout, use the general physicalKeyToAssyrianMap
            else if (currentLayout === 'assyrian') {
                 if (physicalKeyToAssyrianMap[event.key.toLowerCase()]) { // Check for unshifted letters
                    charToInsert = physicalKeyToAssyrianMap[event.key.toLowerCase()];
                    isBaseCharacter = true;
                    event.preventDefault();
                } else if (event.shiftKey && physicalKeyToAssyrianMap[event.key.toUpperCase()]) { // Check for shifted keys (diacritics)
                    charToInsert = physicalKeyToAssyrianMap[event.key.toUpperCase()];
                    if (allVowelsAndDiacritics.includes(charToInsert)) {
                        isBaseCharacter = false;
                        event.preventDefault();
                    }
                }
            }

            // Handle Space and Enter, which are common across layouts
            if (event.key === ' ') {
                charToInsert = ' ';
                isBaseCharacter = true; // Treat space as base for insertion
                event.preventDefault();
            } else if (event.key === 'Enter') {
                charToInsert = '\n';
                isBaseCharacter = true; // Treat newline as base for insertion
                event.preventDefault();
            }


            if (charToInsert !== null) {
                insertAtCursor(charToInsert, isBaseCharacter);
            }
        });

        // PDF upload and navigation event listeners
        pdfUploadInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                loadPdf(file);
            }
        });

        prevPageBtn.addEventListener('click', () => {
            if (pdfDoc && currentPageNum > 1) {
                renderPage(currentPageNum - 1);
            }
        });

        nextPageBtn.addEventListener('click', () => {
            if (pdfDoc && currentPageNum < pdfDoc.numPages) {
                renderPage(currentPageNum + 1);
            }
        });

        // Event listener for the new "Save Text as Image" button
        saveImageBtn.addEventListener('click', saveInputTextAsImage);


        // Initialize OCR Worker and load default PDF when the page loads
        document.addEventListener('DOMContentLoaded', async () => {
            // OCR Worker initialization (always in dark mode now)
            ocrStatusDisplay.textContent = 'Initializing OCR engine (core files)...';
            try {
                ocrWorker = await Tesseract.createWorker({
                    // Explicitly set workerPath for consistency.
                    workerPath: 'https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/worker.min.js',
                    // Updated langPath to JSDelivr path for syr (Syriac)
                    langPath: 'https://cdn.jsdelivr.net/npm/@tesseract.js-data/syr@1.0.0/4.0.0_best_int/', // Corrected to 'syr'
                    logger: m => {
                        if (m.status && m.progress !== undefined) {
                            if (m.status === 'loading tesseract core') {
                                ocrStatusDisplay.textContent = `OCR Core: ${Math.round(m.progress * 100)}% loaded`;
                            } else if (m.status === 'initializing tesseract') {
                                ocrStatusDisplay.textContent = `OCR Initializing: ${Math.round(m.progress * 100)}%`;
                            } else {
                                ocrStatusDisplay.textContent = `OCR: ${m.status} (${Math.round(m.progress * 100)}%)`;
                            }
                        }
                    }
                });
                ocrStatusDisplay.textContent = 'OCR Engine: Loading language data...';
                await ocrWorker.loadLanguage('syr'); // Corrected to 'syr'
                ocrStatusDisplay.textContent = 'OCR Engine: Initializing language...';
                await ocrWorker.initialize('syr'); // Corrected to 'syr'
                ocrStatusDisplay.textContent = 'OCR Engine ready.';

                // Automatically load the specified PDF from the URL
                const defaultPdfUrl = 'https://raw.githubusercontent.com/AI-Assyria/assyrian-bible-workbench/main/ABS%201886.pdf';
                
                // Add a check to ensure the default URL is not the placeholder before trying to load
                if (defaultPdfUrl.includes('YOUR_GITHUB_USERNAME') || defaultPdfUrl.includes('YOUR_REPOSITORY_NAME') || defaultPdfUrl.includes('YOUR_PDF_FILENAME')) {
                    ocrStatusDisplay.textContent = 'OCR Engine ready. Please update the HTML with your PDF URL to auto-load a document.';
                } else {
                    await loadPdf(defaultPdfUrl);
                    ocrStatusDisplay.textContent = 'OCR Engine ready. Default PDF loaded.';
                }


            } catch (error) {
                console.error('Failed to initialize Tesseract.js worker or load default PDF:', error);
                let userMessage = `Error during OCR initialization or default PDF load: ${error && error.name ? error.name : 'Unknown Error'}: ${error && error.message ? error.message : 'No message available'}.`;
                if (error && error.message && (error.message.includes('Failed to fetch') || error.message.includes('Can not load'))) {
                    userMessage += ' This often happens if the page is not served by a local web server (e.g., you opened it directly from your file system). Please ensure you are using a local server (like Python\'s http.server) and try a hard refresh (Ctrl+Shift+R or Cmd+Shift+R) after clearing your browser\'s cache.';
                } else if (error && error.name === 'DataCloneError') {
                     userMessage += ' This suggests an issue with the Web Worker. Please try a hard refresh (Ctrl+Shift+R or Cmd+Shift+R) and clear your browser\'s cache to ensure consistent Tesseract.js component loading.';
                } else if (error && error.message.includes('Tesseract.js: Failed to load language data. You may need to provide a custom "langPath".')) {
                    userMessage += ` It appears the language data for 'syr' could not be loaded from the specified path. Double-check your internet connection and verify that 'https://cdn.jsdelivr.net/npm/@tesseract.js-data/syr@1.0.0/4.0.0_best_int/' is accessible.`;
                }
                ocrStatusDisplay.textContent = userMessage;
            }

            // Initial rendering of keyboard after OCR worker is attempted to be loaded
            renderKeyboard(scriptSelect.value, keyboardLayoutSelect.value);
            updateOutput();
            prevPageBtn.disabled = true;
            nextPageBtn.disabled = false;
        });

    </script>
</body>
</html>
